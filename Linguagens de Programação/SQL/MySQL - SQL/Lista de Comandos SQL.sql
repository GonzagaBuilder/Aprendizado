/*LISTA DE COMANDOS*/

/*MOSTRAR QUAIS OS BANCOS DE DADOS EXISTENTES, AS TABELAS, E SUAS DESCRIÇÕES*/

SHOW DATABASES;

USE NOME_DO_BANCO
SHOW TABLES;

DESC NOME_DA_TABELA;

/*CRIAR E USAR BANCO DE DADOS*/

CREATE DATABASE NOME_DO_BANCO;
USE NOME_DO_BANCO;

/*CRIAR E APAGAR TABELAS*/

CREATE TABLE NOME_DA_TABELA (
    IDNOME_DA_TABELA INT PRIMARY KEY,
    NOME VARCHAR (30) NOT NULL,
    ESTADO CHAR (2),
    CPF VARCHAR (15) UNIQUE,
    SEXO ENUM ('M','F') NOT NULL
);

/*EXEMPLO: TABELA PESSOA CONTÉM TABELAS ENDEREÇO (SÓ UM POR NOME E É OBRIGATÓRIO) 
E TELEFONE (PODE SER MAIS DE UM E NÃO É OBRIGATÓRIO). (OBS: OBRIGATORIEDADE É FEITA POR SOFTWARE):*/

CREATE TABLE PESSOA (
    IDPESSOA INT PRIMARY KEY AUTO_INCREMENT,
    NOME VARCHAR (30) NOT NULL, 
    CPF VARCHAR (15) UNIQUE
);

CREATE TABLE ENDERECO (
    IDENDERECO INT PRIMARY KEY AUTO_INCREMENT,
    RUA VARCHAR (100) NOT NULL,		
    BAIRRO VARCHAR (30) NOT NULL,		
    CIDADE VARCHAR (30) NOT NULL,
    ESTADO CHAR (2) NOT NULL,		
    ID_PESSOA INT UNIQUE /*SÓ UM POR NOME*/
    FOREING KEY (ID_PESSOA)
    REFERENCES PESSOA (IDPESSOA)
);

CREATE TABLE TELEFONE (
    IDTELEFONE INT PRIMARY KEY AUTO_INCREMENT,
    TIPO ENUM ('CEL','COM','RES') NOT NULL,
    DDD CHAR (3) NOT NULL,
    NÚMERO VARHAR (10) NOT NULL,		
    ID_PESSOA INT /*PODE TER MAIS DE UM POR NOME*/
    FOREING KEY (ID_PESSOA)
    REFERENCES PESSOA (IDPESSOA)
);

DROP TABLE NOME_DA_TABELA;

/*ALTERANDO AS PROPRIEDADES DE UMA TABELA*/

ALTER TABLE NOME_DA_TABELA	/*MELHOR PARA ALTERAR NOME DE COLUNA*/
    CHANGE NOME NOME_DO_CIDADÃO VARCHAR (8000) NOT NULL;
     	
ALTER TABLE NOME_DA_TABELA	/*MELHOR PARA ALTERAR TIPO DO DADO*/
    MODIFY NOME_DO_CIDADÃO VARCHAR (300) NOT NULL;

ALTER TABLE NOME_DA_TABELA	/*ADICIONA UMA NOVA COLUNA*/
    ADD PESO FLOAT (10,2) NOT NULL;

ALTER TABLE NOME_DA_TABELA	/*APAGANDO UMA COLUNA*/
    DROP COLUMN PESO;

/*CONTAR DADOS DE UMA TABELA PARA ANALISAR DADOS*/

SELECT COUNT (*)
FROM NOME_DA_TABELA;

SELECT SEXO, COUNT (*)
FROM NOME_DA_TABELA
GROUP BY SEXO;

SELECT SEXO, COUNT (*)
FROM NOME_DA_TABELA
GROUP BY SEXO
ORDER BY 1;

/*SOMENTE PROJETAR INFORMAÇÕES, OU FILTRAR DADOS DESEJÁVEIS E PROJETÁ-LOS*/

SELECT NOW ( );

SELECT NOW ( ) AS DATA_HORA, 'GONZAGA' AS TRABALHADOR;

SELECT NOME, SEXO, NOW ( ) AS DATA_HORA	/*PROJEÇÃO NA TELA*/
FROM NOME_DA_TABELA /*ORIGEM DA INFORMAÇÃO*/
WHERE NOME = 'GONZAGA';	/*SELEÇÃO DO SUBCONJUNTO*/

SELECT NOME, SEXO, NOW ( ) AS DATA_HORA 
FROM NOME_DA_TABELA 
WHERE NOME LIKE 'GON%';

SELECT * 
FROM NOME_DA_TABELA;

SELECT NOME, ESTADO, CFP, SEXO 
FROM NOME_DA_TABELA
WHERE SEXO = 'M' 
AND (ESTADO ='SP' OR ESTADO = 'RJ');

SELECT NOME, SEXO, ESTADO
FROM NOME_DA_TABELA
WHERE ESTADO IS NULL;

SELECT NOME, SEXO, ESTADO
FROM NOME_DA_TABELA
WHERE ESTADO IS NOT NULL;

/*INSERIR DADOS EM UMA TABELA*/

INSERT INTO NOME_DA_TABELA (CPF, NOME)
VALUES ('000.000.000-00','JOÃO NINGUÉM');

INSERT INTO NOME_DA_TABELA
VALUES (NULL,'MARIA NINGUÉM','SP','000.000.111-11','F');

INSERT INTO ENDERECO 
VALUES (NULL,'RUA ANTONIO SA','CENTRO','B. HORIZONTE','MG',4);

/*DELETAR DADOS DE UMA TABELA

1º Conte os dados totais e os a serem deletados
2º Projete os dados a serem deletados
3º Delete os dados
4º Confira a contagem*/

DELETE FROM NOME_DA_TABELA
WHERE CPF = '000.000.000-00';

/*ATUALIZAR DADOS

1º Projete os dados a serem atualizados
2º Atualize os dados*/

UPDATE NOME_DA_TABELA 
SET ESTADO = 'MS'
WHERE ID_NOME_DA_TABELA = 49;

/*PROJETANDO E ATUALIZANDO CONJUNTO DE DADOS*/

SELECT * FROM CLIENTE
WHERE IDCLIENTE IN (6,10,11,12,16,17);

UPDATE CLIENTE SET SEXO = 'F'
WHERE IDCLIENTE IN (6,10,11,12,16,17);

/*JUNÇÃO DE DADOS - JOIN*/

SELECT NOME, SEXO, ESTADO	/*PROJEÇÃO*/
FROM PESSOA /*ORIGEM*/
INNER JOIN ENDERECO
ON IDPESSOA = ID_PESSOA /*JUNÇÃO*/
WHERE ESTADO = 'MG'; /*SELEÇÃO*/

/*JUNÇÃO DE MAIS DE 2 TABELAS COM PONTEIRAMENTO:*/

SELECT PESSOA.NOME, ENDERECO.CIDADE, TELEFONE.DDD, TELEFONE.NÚMERO	/*PROJEÇÃO*/
FROM PESSOA /*ORIGEM*/
INNER JOIN ENDERECO
ON PESSOA.IDPESSOA = ENDERECO.ID_PESSOA	/*JUNÇÃO*/
INNER JOIN TELEFONE
ON PESSOA.IDPESSOA = TELEFONE.ID_PESSOA; /*JUNÇÃO*/

/*JUNÇÃO DE MAIS DE 2 TABELAS COM PONTEIRAMENTO USANDO ALIAS (APELIDOS):*/

SELECT P.NOME, E.CIDADE, T.DDD, T.NÚMERO    /*PROJEÇÃO*/
FROM PESSOA P	/*ORIGEM*/
INNER JOIN ENDERECO E
ON P.IDPESSOA = E.ID_PESSOA	/*JUNÇÃO*/
INNER JOIN TELEFONE T
ON P.IDPESSOA = T.ID_PESSOA; /*JUNÇÃO*/

/*FUNÇÕES – (ELAS PODEM SER COM PARAMETROS E SEM PARAMETROS) – IFNULL(MYSQL) – 

    FUNÇÃO IFNULL TROCA O QUE ESTIVER APARECENDO COMO NULL, POR ALGO QUE SE QUEIRA*/

SELECT  C.NOME, 
		IFNULL(C.EMAIL,'NAO TEM EMAIL') AS 'EMAIL' 
		E.ESTADO, 
		T.NUMERO
FROM CLIENTE C
INNER JOIN ENDERECO E
ON C.IDCLIENTE = E.ID_CLIENTE
INNER JOIN TELEFONE T
ON C.IDCLIENTE = T.ID_CLIENTE;

/*LISTA DE PROCEDIMENTOS LÓGICOS PARA BANCO DE DADOS

LÓGICA OR E AND COM RELAÇÃO A PERFORMANCE

    Mais dados, OR primeiro, porque se o primeiro é VERDADEIRO, ele não olha o segundo.
    Menos dados, AND primeiro, porque só passa para o segundo, se o primeiro é VERDADEIRO.

REGRAS DE CARDINALIDADE (obrigatoriedade, quantidade de dados)

    BANCO DE DADOS NÃO DEFINE OBRIGATORIEDADE, PRECISA SER FEITO NA CAMADA DE SOFTWARE

    TIPOS DE CARDINALIDADE EM RELAÇÃO AOS DADOS:

        (1,1) – obrigatório, com dado único
        (0,1) – não obrigatório, com dado único
        (1,N) – obrigatório, com ‘n’ dados possíveis
        (0,N) – não obrigatório, com ‘n’ dados possíveis

FOREIGN KEY (FK)

    RELACIONAMENTOS:
        1X1 – FK NA TABELA MAIS FRACA
        1XN – FK SEMPRE NA CARDINALIDADE N

SOBRE AS LINGUAGENS DE TRATAMENTO DE DADOS

    DML - DATA MANIPULATION LANGUAGE
        INSERT, SELECT, UPDATE, DELETE

    DDL - DATA DEFINITION LANGUAGE
        TIPAGEM DE DADOS (INT, VARCHAR, FLOAT), ALTER TABLE, CHANGE, MODIFY, DROP
	
    DCL - DATA CONTROL LANGUAGE
        d

    TCL - TRANSACTION CONTROL LANGUAGE*/

/*FUNÇÕES - BLOCO DE PROGRAMAÇÃO QUE EXECUTA UMA TAREFA*/

--FUNÇÃO PARA ESCONDER OS RESULTADOS 'NULL' DAS QUERYS
IFNULL(NOME_DA_COLUNA,'*************') AS 'NOME_DA_COLUNA';

/*VIEW - É UM PONTEIRO QUE APONTA PARA A QUERY, PARA NÃO FICAR REPETINDO QUERYS*/
CREATE VIEW V_CONTAGEM_DE_SEXO AS
SELECT SEXO, COUNT (*)
FROM NOME_DA_TABELA
GROUP BY SEXO
ORDER BY 1;

SELECT * FROM V_CONTAGEM_DE_SEXO;
-- É SÓ UTILIZAR ESSE SELECT PRA TRAZER ESSA QUERY "PROGRAMADA"

/*AS VIEWS SÃO CRIADAS COMO TABELAS, ENTÃO O COMANDO SHOW TABLES, MOSTRA ELAS*/
--A VIEW PODE FAZER UMA PERDA DE PERFORMANCE, MAS É UMA TROCA
--É POSSÍVEL FAZER UMA QUERY DA QUERY TAMBÉM, OU SEJA, UM SELECT DA VIEW.

/*NÃO É POSSÍVEL FAZER INSERT E DELETE EM VIEWS COM JOIN, MAS É POSSÍVEL
FAZER UM UPDATE, PORÉM ELA SÓ ALTERA A VIEW E NÃO A TABELA, E SEM O JOIN
É POSSÍVEL FAZER TUDO SOMENTE NA VIEW*/

/*ORDER BY*/

ORDER BY NOME_DA_COLUNA;--O MELHOR É SEMPRE ORDENAR PELO NOME
--OU
ORDER BY 1; --O NÚMERO 1 É O ÍNDICE DA COLUNA
--OU
ORDER BY 1, 2; --ORDENA PRIMEIRO PELA COLUNA 1 E DEPOIS PELA COLUNA 2
--OU
ORDER BY 2 ASC;--POR PADRÃO, SE NÃO INDICAR, TODO ORDER BY É ASCENDENTE
--OU
ORDER BY 1 DESC;--ORDENA DE FORMA DESCENDENTE

/*DELIMITADOR - CARACTÉR QUE AUTORIZA O COMANDO PARA O BANCO DE DADOS*/

DELIMITER $
-- A PARTIR DAÍ OS COMANDOS SERÃO EXECUTADOS APENAS APÓS O CARACTÉR '$' E NÃO MAIS PELO ';'

/*STORDE PROCEDURES - PROCEDIMENTOS ARMAZENADOS NO BANCO DE DADOS, QUE SÃO BLOCOS NOMEADOS, 
DIFERENTE DO QUE ATÉ ENTÃO ERA FEITO, E CHAMÁVAMOS DE BLOCOS ANONIMOS*/

--É NECESSÁRIO TROCAR O DELIMITER PARA FUNCIONAR A PROGRAMAÇÃO DA PROCEDURE

DELIMITER $

CREATE PROCEDURES NOME_DA_PROCEDURE()
BEGIN

    SELECT 'A PROCEDURE É SÓ PRA EXIBIR ISSO' AS 'OLHA ISSO';

END
$

--EXEMPLO DE CALCULADORA CRIADA NUMA PROCEDURE

CREATE PROCEDURE CONTA(NUMERO1 INT, NUMERO2 INT)
BEGIN

    SELECT NUMERO1 + NUMERO2 AS 'CONTA';

END
$

-- AGORA PARA CHAMAR ESSA PROCEDURE

CALL CONTA (3000,200)$

/*PROCEDURE UM POUCO MAIS COMPLEXA, MAIS REALISTA
AQUI ESTAMOS CRIANDO A REGRA DE NEGÓCIO DENTRO DO BANCO DE DADOS*/

--CRIANDO TABELA PARA TESTAR PROCEDURES:
CREATE TABLE CURSOS(
    IDCURSOS INT PRIMARY KEY AUTO_INCREMENT,
    NOME VARCHAR(30) NOT NULL,
    HORAS INT(3) NOT NULL,
    VALOR FLOAT(10,2) NOT NULL
);

--INSERINDO DADOS NELA:
INSERT INTO CURSOS VALUES (NULL, 'JAVA', 30, 500.00)
INSERT INTO CURSOS VALUES (NULL, 'C++', 40, 700.00)

--PROCEDURE PARA CADASTRAR OS DADOS:
DELIMITER #
STATUS --PARA CONFERIR O DELIMITADOR QUE FOI COLOCADO

CREATE PROCEDURE CONTA(NUMERO1 INT, NUMERO2 INT)
BEGIN

    SELECT NUMERO1 + NUMERO2 AS 'CONTA';

END
#



